---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Hero from '../components/Hero.astro';
import About from '../components/About.astro';
import Experience from '../components/Experience.astro';
import Skills from '../components/Skills.astro';
import Projects from '../components/Projects.astro';
import Contact from '../components/Contact.astro';
import Footer from '../components/Footer.astro';
---

<Layout title="Alex Parada | Desarrollador Full Stack">
  <Header />
  <main>
    <Hero />
    <About />
    <Experience />
    <Skills />
    <Projects />
    <Contact />
  </main>
  <Footer />
</Layout>

<style is:global>
  /* Smooth scroll behavior */
  html {
    scroll-behavior: smooth;
  }
  
  /* Page load animation */
  body {
    opacity: 0;
    animation: pageLoad 0.5s ease forwards;
  }
  
  @keyframes pageLoad {
    to {
      opacity: 1;
    }
  }
  
  /* Focus styles for accessibility */
  :focus-visible {
    outline: 2px solid var(--color-accent-primary);
    outline-offset: 2px;
  }
</style>

<script>
  // ==========================================
  // SCROLL ANIMATION SYSTEM
  // Using Intersection Observer API
  // ==========================================
  
  document.addEventListener('DOMContentLoaded', () => {
    // Seleccionar todos los elementos con data-animate
    const animatedElements = document.querySelectorAll('[data-animate]');
    
    // Opciones del observer
    const observerOptions: IntersectionObserverInit = {
      root: null, // viewport
      rootMargin: '0px 0px -10% 0px', // trigger un poco antes de entrar
      threshold: 0.1 // 10% visible
    };
    
    // Callback cuando un elemento entra/sale del viewport
    const observerCallback: IntersectionObserverCallback = (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          // Agregar clase para activar animación
          entry.target.classList.add('is-visible');
          
          // Opcional: dejar de observar después de animar (mejor rendimiento)
          // observer.unobserve(entry.target);
        } else {
          // Opcional: quitar clase cuando sale (para re-animar al volver)
          // entry.target.classList.remove('is-visible');
        }
      });
    };
    
    // Crear el observer
    const observer = new IntersectionObserver(observerCallback, observerOptions);
    
    // Observar todos los elementos animados
    animatedElements.forEach((el) => {
      observer.observe(el);
    });
    
    // ==========================================
    // PARALLAX SUAVE EN SCROLL (opcional)
    // ==========================================
    
    const parallaxElements = document.querySelectorAll('[data-parallax]');
    
    if (parallaxElements.length > 0) {
      let ticking = false;
      
      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            const scrollY = window.scrollY;
            
            parallaxElements.forEach((el) => {
              const speed = parseFloat((el as HTMLElement).dataset.parallax || '0.5');
              const yPos = -(scrollY * speed);
              (el as HTMLElement).style.transform = `translateY(${yPos}px)`;
            });
            
            ticking = false;
          });
          
          ticking = true;
        }
      });
    }
    
    // ==========================================
    // ACTIVE NAV LINK ON SCROLL
    // ==========================================
    
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.nav-link');
    
    const navObserverOptions: IntersectionObserverInit = {
      root: null,
      rootMargin: '-20% 0px -80% 0px',
      threshold: 0
    };
    
    const navObserverCallback: IntersectionObserverCallback = (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          
          navLinks.forEach((link) => {
            link.classList.remove('active');
            if (link.getAttribute('href') === `#${id}`) {
              link.classList.add('active');
            }
          });
        }
      });
    };
    
    const navObserver = new IntersectionObserver(navObserverCallback, navObserverOptions);
    
    sections.forEach((section) => {
      navObserver.observe(section);
    });
  });
</script>